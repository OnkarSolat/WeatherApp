'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _focusTrap = require('focus-trap');

var _focusTrap2 = _interopRequireDefault(_focusTrap);

var _tabbable = require('tabbable');

var _tabbable2 = _interopRequireDefault(_tabbable);

var _isElementScrolledIntoView = require('./is-element-scrolled-into-view');

var _isElementScrolledIntoView2 = _interopRequireDefault(_isElementScrolledIntoView);

var _popoverPositioner = require('./popover-positioner');

var _popoverPositioner2 = _interopRequireDefault(_popoverPositioner);

var _querySelectorContainsNode = require('@mapbox/query-selector-contains-node');

var _querySelectorContainsNode2 = _interopRequireDefault(_querySelectorContainsNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var popoverCounter = 0; // Incremented on creation

/**
 * Display a popover. The popover is positioned relative to an anchor element,
 * and the preferred position determined by props is adjusted according to the
 * available space.
 *
 * If there's a trigger that opens and closes the popover, you should consider
 * using PopoverTrigger, instead, which internally manages the Popover.
 *
 * If you are using this component directly, you need to manage its open-closed
 * state. Use `onExit` to do that.
 */

var Popover = function (_React$Component) {
  _inherits(Popover, _React$Component);

  function Popover(props) {
    _classCallCheck(this, Popover);

    var _this = _possibleConstructorReturn(this, (Popover.__proto__ || Object.getPrototypeOf(Popover)).call(this, props));

    _initialiseProps.call(_this);

    popoverCounter += 1;
    _this.popoverId = popoverCounter;
    return _this;
  }

  _createClass(Popover, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      // For focus management: focus will return to this element
      // when the popover is closed
      this.previouslyFocusedElement = document.activeElement;
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      this.hackListenerRemovers = [];
      if ('ontouchstart' in document.documentElement) {
        // Prevent a full-screen flash when there's a click.
        document.documentElement.style.WebkitTapHighlightColor = 'transparent';
        var bodyChildren = document.body.childNodes;

        var _loop = function _loop(i, l) {
          var node = bodyChildren[i];
          // Hack to fix click event bubbling in iOS
          // cf. https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
          // Without this, a tap in iOS outside the popover will not close it.
          node.addEventListener('mouseover', noop);
          _this2.hackListenerRemovers.push(function () {
            node.removeEventListener('mouseover', noop);
          });
        };

        for (var i = 0, l = bodyChildren.length; i < l; i++) {
          _loop(i, l);
        }
      }
      // Listen for mousedown rather than click in the case that the Popover
      // trigger is an input. This ensures that onDocumentMousedown is called
      // first and does not unintentionally remove focus from the popover.
      document.addEventListener('mousedown', this.onDocumentMousedown);
      // Delay this focus because of
      // https://github.com/mapbox/www2.mapbox.com/issues/283
      // If you go from one popover to another, we need focus to
      // hit the first popover's trigger and *then* enter this popover's body
      this.focusBodyTimer = setTimeout(function () {
        _this2.maybeFocusPopover();
      }, 10);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      // This is necessary if, for example, you've hovered over
      // a PopoverTrigger and *then* clicked it: it's already mounted
      // but only *now* should receive focus. Logic within maybeFocusPopover
      // will prevent us from re-focusing if we've already focused.
      this.maybeFocusPopover();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.hackListenerRemovers.forEach(function (r) {
        return r();
      });
      document.removeEventListener('mousedown', this.onDocumentMousedown);
      if (this.focusBodyTimer) clearTimeout(this.focusBodyTimer);

      if (this.focusTrap) {
        this.focusTrap.deactivate();
        var previouslyFocusedElement = this.previouslyFocusedElement;
        // We must defer this call in order for a parent popover's
        // onBodyFocus method to pick up on the programmatic focus
        // https://github.com/facebook/react/issues/7835

        setTimeout(function () {
          // Only focus if it's visible, to avoid semi-mysterious scroll bouncing
          if (previouslyFocusedElement && (0, _isElementScrolledIntoView2.default)(previouslyFocusedElement)) {
            previouslyFocusedElement.focus();
          }
        }, 0);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        _popoverPositioner2.default,
        {
          getAnchorElement: this.props.getAnchorElement,
          hasPointer: this.props.hasPointer,
          placement: this.props.placement,
          alignment: this.props.alignment,
          pointerColor: this.props.backgroundColor,
          hideWhenAnchorIsOffscreen: this.props.hideWhenAnchorIsOffscreen,
          allowPlacementAxisChange: this.props.allowPlacementAxisChange,
          containWithinViewport: this.props.containWithinViewport,
          getContainingElement: this.props.getContainingElement,
          offsetFromAnchor: this.props.offsetFromAnchor,
          onElement: this.setPopoverElement
        },
        _react2.default.createElement(
          'div',
          _extends({
            key: 'body',
            style: { backgroundColor: this.props.backgroundColor },
            className: this.props.themePopover,
            onKeyDown: this.onBodyKeyDown,
            onFocus: this.onBodyFocus,
            'data-popover-id': this.popoverId,
            tabIndex: -1,
            'aria-label': this.props.accessibleTitle,
            role: 'dialog'
          }, this.props.contentElementAttributes),
          this.props.children
        )
      );
    }
  }]);

  return Popover;
}(_react2.default.Component);

Popover.propTypes = {
  /** A function that returns the DOM node to which this Popover should be anchored. `placement` and `alignment` values are related to this anchor. */
  getAnchorElement: _propTypes2.default.func.isRequired,
  /** The content of the popover. */
  children: _propTypes2.default.node.isRequired,
  /** Preferred placement of the popover in relation to the anchor. Adjusted according to available space. */
  placement: _propTypes2.default.oneOf(['top', 'bottom', 'left', 'right']),
  /** Alignment of the popover relative to the side of the anchor on which it's placed. If `placement` is `left` or `right`, meaningful `alignment` values are `top`, `bottom`, and `center`. If `placement` is `top` or `bottom`, meaningful `alignment` values are `left`, `right`, and `center`. Adjusted according to available space. */
  alignment: _propTypes2.default.oneOf(['top', 'bottom', 'left', 'right', 'center']),
  /** Background color of the popover. */
  backgroundColor: _propTypes2.default.string,
  /** Pass custom classes to style the popover container. */
  themePopover: _propTypes2.default.string,
  /** Whether or not the popover has a triangle pointer. */
  hasPointer: _propTypes2.default.bool,
  /** If `true`, the popover will hide when its anchor is scroll offscreen. By default, the popover will follow its anchor. If the anchor is within an internally scrolling area, you may want to use `true`. */
  hideWhenAnchorIsOffscreen: _propTypes2.default.bool,
  /** If `false`, the popover is not allowed to change axes on the anchor when modifying its position to fit available space. By default, popovers on the `left` and `right`, for example, might change to `bottom` is there is neither space on the left nor the right. */
  allowPlacementAxisChange: _propTypes2.default.bool,
  /** If `false`, the tooltip is allowed to leave the viewport. By default, it will stick to the edge of the viewport as its anchor scrolls out of sight. */
  containWithinViewport: _propTypes2.default.bool,
  /** If `false`, clicking outside the popver will not close it. By default, it does. */
  clickOutsideCloses: _propTypes2.default.bool,
  /** If `false`, hitting Escape will not close the popover. By default, it does. */
  escapeCloses: _propTypes2.default.bool,
  /** If `true`, the popover will not receive focus when it opens. By default, it does. */
  receiveFocus: _propTypes2.default.bool,
  /** If `true`, the popover will receive *and trap* focus when it opens. */
  trapFocus: _propTypes2.default.bool,
  /** A title for the popover that will be legible for screen readers. *You should use this.* It's optional, though, because Tooltip does not need it, but attains accessibility by other means. */
  accessibleTitle: _propTypes2.default.string,
  /** A function called when popover is dismissed. You need to use this callback to remove the Popover from the rendered page. */
  onExit: _propTypes2.default.func,
  /** A function to call as soon as popover element is rendered. Returns the DOM node of the popover body.  */
  onElement: _propTypes2.default.func,
  /** A function that returns a DOM node. Use to specify which element is focused when popover is first rendered. */
  getInitialFocus: _propTypes2.default.func,
  /** A function called when an element within the popover is clicked. */
  ignoreClickWithinElement: _propTypes2.default.func,
  /** A function that returns a DOM node that should contain the popover within it. The popover's position will be calculated relative to this container, rather than the viewport. */
  getContainingElement: _propTypes2.default.func,
  /** See options for calculatePopoverPosition. */
  offsetFromAnchor: _propTypes2.default.number,
  /** Attributes to pass to the `<div>` that will wrap your popover content. */
  contentElementAttributes: _propTypes2.default.object
};
Popover.defaultProps = {
  placement: 'right',
  alignment: 'top',
  backgroundColor: '#fff',
  themePopover: 'round py6 px12 shadow-darken25',
  hasPointer: true,
  hideWhenAnchorIsOffscreen: false,
  allowPlacementAxisChange: true,
  containWithinViewport: true,
  clickOutsideCloses: true,
  escapeCloses: true,
  receiveFocus: true,
  trapFocus: false
};
Popover.repositionPopovers = _popoverPositioner2.default.recalculatePositions;

var _initialiseProps = function _initialiseProps() {
  var _this3 = this;

  this.maybeFocusPopover = function () {
    if (!_this3.bodyElement) return;
    var props = _this3.props;


    if (!_this3.focusTrap && props.trapFocus) {
      _this3.focusTrap = (0, _focusTrap2.default)(_this3.bodyElement, {
        escapeDeactivates: props.escapeCloses,
        clickOutsideDeactivates: props.clickOutsideCloses,
        returnFocusOnDeactivate: false,
        initialFocus: props.getInitialFocus ? props.getInitialFocus() : undefined,
        fallbackFocus: _this3.bodyElement
      });
      _this3.focusTrap.activate();
      return;
    }

    if (!_this3.hasReceivedFocus && props.receiveFocus) {
      _this3.hasReceivedFocus = true;
      var initialFocusNode = void 0;
      if (props.getInitialFocus) {
        initialFocusNode = props.getInitialFocus();
      } else {
        var tabbableNodes = (0, _tabbable2.default)(_this3.bodyElement, {
          includeContainer: true
        });
        initialFocusNode = tabbableNodes[0];
      }
      if (initialFocusNode && initialFocusNode.focus) {
        initialFocusNode.focus();
      }
    }
  };

  this.onDocumentMousedown = function (event) {
    var onExit = _this3.props.onExit;

    if (!_this3.bodyElement || !onExit) return;
    if (_this3.bodyElement.contains(event.target)) return;
    if (_this3.elementIsWithinChildPopover(event.target)) return;
    if (event.button === 2) return; // Ignore right-click mouse operation
    if ((0, _querySelectorContainsNode2.default)('[data-popover-ignore-clicks]', event.target)) return;
    if (_this3.props.ignoreClickWithinElement && _this3.props.ignoreClickWithinElement(event.target)) {
      return;
    }
    onExit();
  };

  this.onBodyKeyDown = function (event) {
    if (_this3.props.onExit && _this3.props.escapeCloses && event.key === 'Escape') {
      _this3.props.onExit();
    }
  };

  this.onBodyFocus = function () {
    if (!_this3.bodyElement) return;
    if (_this3.focusTrap) {
      _this3.focusTrap.unpause();
    }
  };

  this.elementIsWithinChildPopover = function (element) {
    var elementPopoverId = element.getAttribute('data-popover-id');
    if (elementPopoverId) {
      return Number(elementPopoverId) > _this3.popoverId;
    } else if (element.parentElement && element.parentElement !== document) {
      return _this3.elementIsWithinChildPopover(element.parentElement);
    }
    return false;
  };

  this.setPopoverElement = function (element) {
    _this3.bodyElement = element;
    if (_this3.props.onElement) _this3.props.onElement(element);
  };
};

exports.default = Popover;


function noop() {}