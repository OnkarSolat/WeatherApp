'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _hoverintent = require('hoverintent');

var _hoverintent2 = _interopRequireDefault(_hoverintent);

var _reactPopover = require('@mapbox/react-popover');

var _reactPopover2 = _interopRequireDefault(_reactPopover);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TRIGGER_HOVER = 'hover';
var TRIGGER_FOCUS = 'focus';
var TRIGGER_CLICK = 'click';

var PopoverTrigger = function (_React$Component) {
  _inherits(PopoverTrigger, _React$Component);

  function PopoverTrigger() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, PopoverTrigger);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = PopoverTrigger.__proto__ || Object.getPrototypeOf(PopoverTrigger)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      visible: false,
      activeTriggerType: null
    }, _this.openPopover = function (trigger, callback) {
      var alreadyOpen = !!_this.state.visible;
      _this.setState({
        visible: true,
        activeTriggerType: trigger
      }, function () {
        if (!alreadyOpen && _this.props.onPopoverOpen) {
          _this.props.onPopoverOpen();
        }
        if (callback) callback();
      });
    }, _this.closePopover = function (callback) {
      var alreadyClosed = !_this.state.visible;
      _this.setState({
        visible: false,
        activeTriggerType: null
      }, function () {
        if (!alreadyClosed && _this.props.onPopoverClose) {
          _this.props.onPopoverClose();
        }
        if (callback) callback();
      });
    }, _this.onAnyClick = function (event) {
      if (!_this.hoverIsBlocked && (_this.props.disabled || !_this.props.respondsToClick)) {
        return;
      }

      if (_this.state.visible && _this.state.activeTriggerType === TRIGGER_CLICK && (!_this.popoverElement || !_this.popoverElement.contains(event.target))) {
        _this.hide();
      } else {
        _this.showBecauseClick();
      }
    }, _this.blockHover = function () {
      if (!_this.hoverIsBlocked) {
        _this.hoverIsBlocked = true;
        _this.addMouseMoveUnblockTimeout = setTimeout(function () {
          document.addEventListener('mousemove', _this.unblockHover);
        }, 100);
      }
    }, _this.unblockHover = function () {
      if (_this.hoverIsBlocked) {
        _this.hoverIsBlocked = false;
        document.removeEventListener('mousemove', _this.unblockHover);
      }
    }, _this.onTriggerMouseEnter = function () {
      if (_this.props.disabled || !_this.props.respondsToHover || _this.state.activeTriggerType && _this.state.activeTriggerType !== TRIGGER_HOVER || _this.hoverIsBlocked) {
        return;
      }

      _this.showBecauseHover();
    }, _this.onTriggerMouseLeave = function (event) {
      if (_this.props.disabled || !_this.props.respondsToHover || _this.state.activeTriggerType !== TRIGGER_HOVER || _this.hoverIsBlocked) {
        return;
      }

      // When you hover over the popover, you do not want to disappear from beneath
      // your cursor. This keeps the popover open when your cursor is within it.
      if (!_this.popoverElement || !_this.popoverElement.contains(event.relatedTarget)) {
        _this.hideBecauseHover();
      }
    }, _this.onPopoverMouseLeave = function (event) {
      if (_this.props.disabled || !_this.props.respondsToHover || _this.state.activeTriggerType !== TRIGGER_HOVER || _this.hoverIsBlocked) {
        return;
      }

      if (!_this.triggerElement || !_this.triggerElement.contains(event.relatedTarget)) {
        _this.hideBecauseHover();
      }
    }, _this.onTriggerFocus = function () {
      if (_this.props.disabled || !_this.props.respondsToFocus || _this.state.visible || _this.triggerFocusIsBlocked) {
        return;
      }

      _this.showBecauseTriggerFocus();
    }, _this.onTriggerBlur = function () {
      if (_this.props.disabled || !_this.props.respondsToFocus || !_this.state.visible || _this.state.activeTriggerType !== TRIGGER_FOCUS) {
        return;
      }

      _this.hide();
    }, _this.onTriggerKeyDown = function (event) {
      var escapeCloses = _this.props.popoverProps.escapeCloses;
      if (escapeCloses === false) return;
      if (event.key === 'Escape') {
        _this.hide();
      }
    }, _this.showBecauseClick = function () {
      _this.clearTimeouts();
      _this.removePopoverListeners();
      _this.openPopover(TRIGGER_CLICK);
    }, _this.showBecauseHover = function () {
      _this.openPopover(TRIGGER_HOVER);
    }, _this.showBecauseTriggerFocus = function () {
      _this.clearTimeouts();
      _this.removePopoverListeners();
      _this.openPopover(TRIGGER_FOCUS);
    }, _this.hideBecauseHover = function () {
      _this.hide();
    }, _this.hide = function () {
      if (!_this.state.visible) return;
      _this.clearTimeouts();
      _this.removePopoverListeners();
      _this.closePopover();

      // If focus was inside the popover, after the popover closes focus will
      // return to the trigger. We need to prevent that from re-opening the
      // trigger.
      _this.triggerFocusIsBlocked = true;
      _this.cancelTriggerFocusIsBlockedTimeout = setTimeout(function () {
        _this.triggerFocusIsBlocked = false;
      }, 100);
    }, _this.removePopoverListeners = function () {
      var _this2 = _this,
          popoverElement = _this2.popoverElement;

      if (!popoverElement) return;
      popoverElement.removeEventListener('mouseleave', _this.onPopoverMouseLeave);
    }, _this.ignoreClickWithinElement = function (element) {
      if (_this.triggerElement && _this.triggerElement.contains(element)) return true;
      var ignoreClickWithinElement = _this.props.popoverProps.ignoreClickWithinElement;
      if (ignoreClickWithinElement) {
        return ignoreClickWithinElement(element);
      }
      return false;
    }, _this.getAnchorElement = function () {
      var getAnchorElement = _this.props.popoverProps.getAnchorElement;
      if (getAnchorElement) {
        return getAnchorElement();
      }
      return _this.triggerElement.firstChild;
    }, _this.setTriggerElement = function (element) {
      _this.triggerElement = element;
    }, _this.setPopoverElement = function (element) {
      _this.popoverElement = element;
    }, _this.getPopoverContent = function () {
      var content = _this.props.content;

      if (typeof content === 'function') {
        return content();
      } else {
        return content;
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(PopoverTrigger, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (!this.triggerElement) return;
      this.triggerElement.addEventListener('touchstart', this.blockHover);
      this.triggerElement.addEventListener('mouseout', this.onTriggerMouseLeave);
      this.hoverListener = (0, _hoverintent2.default)(this.triggerElement, this.onTriggerMouseEnter, function () {});
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      var popoverElement = this.popoverElement;

      var justOpened = prevState.visible === false && this.state.visible === true;

      if (justOpened && popoverElement &&
      // If the popover was opened by hover, pay attention to hovering
      // within the popover itself
      this.state.activeTriggerType === TRIGGER_HOVER) {
        popoverElement.addEventListener('mouseleave', this.onPopoverMouseLeave);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.hoverListener.remove();
      this.triggerElement.removeEventListener('touchstart', this.blockHover);
      document.removeEventListener('mousemove', this.unblockHover);
      this.clearTimeouts();
    }

    // A trigger interaction always takes precedence over hover or focus interactions.
    // If the popover is already open by hover or focus, a click will change its
    // priorities, so it stays open even if you mouseleave or blur


    // We need to prevent a touch-tap on the trigger from triggering the hover
    // interaction. So if you touchstart, we immediately block responses to hover
    // interactions; then after a short delay (to allow the event to flush?), we
    // re-allow hover interactions —— in case you're a crazy person and switch
    // from a touchscreen to a mouse.


    // Hover and focus interactions do not overlap: if the popover opened because
    // of a hover (and no clicking), it will only close when you mouseleave;
    // and if it opened because of a focus (and no clicking), it will only close
    // when you blur.

    // This can override a popover-hover trigger type because you might mouseleave
    // the popover onto the trigger

  }, {
    key: 'clearTimeouts',
    value: function clearTimeouts() {
      if (this.cancelTriggerFocusIsBlockedTimeout) clearTimeout(this.cancelTriggerFocusIsBlockedTimeout);
      if (this.addMouseMoveUnblockTimeout) clearTimeout(this.addMouseMoveUnblockTimeout);
    }
  }, {
    key: 'render',
    value: function render() {
      var props = this.props,
          state = this.state;


      var popover = null;
      if (state.visible) {
        // Only send focus inside if we've clicked to open
        var receiveFocus = props.receiveFocus && state.activeTriggerType !== TRIGGER_CLICK;
        var trapFocus = props.trapFocus && state.activeTriggerType !== TRIGGER_CLICK;

        popover = _react2.default.createElement(
          _reactPopover2.default,
          _extends({
            onExit: this.hide
          }, props.popoverProps, {
            getAnchorElement: this.getAnchorElement,
            ignoreClickWithinElement: this.ignoreClickWithinElement,
            receiveFocus: receiveFocus,
            trapFocus: trapFocus,
            onElement: this.setPopoverElement
          }),
          this.getPopoverContent()
        );
      }

      // Tooltips need to the popover content to be present in the DOM
      // with the appropriate id, so aria-labelledby will work
      var hiddenContent = null;
      if (!state.visible && props.renderHiddenContent) {
        hiddenContent = _react2.default.createElement(
          'div',
          _extends({
            className: 'hide-visually'
          }, this.props.popoverProps.contentElementAttributes || {}),
          this.getPopoverContent()
        );
      }

      return _react2.default.createElement(
        'div',
        _extends({
          ref: this.setTriggerElement,
          style: { display: props.display }
        }, props.triggerProps, {
          onClick: this.onAnyClick,
          onFocus: this.onTriggerFocus,
          onBlur: this.onTriggerBlur,
          onKeyDown: this.onTriggerKeyDown
        }),
        props.children,
        hiddenContent,
        popover
      );
    }
  }]);

  return PopoverTrigger;
}(_react2.default.Component);

PopoverTrigger.propTypes = {
  /** The trigger content. This can either be a string or valid JSX. */
  children: _propTypes2.default.node.isRequired,
  /** Accepts a CSS `display` value. */
  display: _propTypes2.default.string,
  /** The popover content. This can either be a string, valid JSX, or a function returning either. */
  content: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.node]),
  /** If `true`, the popover will always be rendered, and will be hidden when inactive.
   * By default, the popover is added to and removed from the DOM dynamically. This prop is used by Tooltip for accessbility reasons.
   */
  renderHiddenContent: _propTypes2.default.bool,
  /** Whether or not the popover receives focus when it opens. */
  receiveFocus: _propTypes2.default.bool,
  /** Whether or not the popover receives *and traps* focus when it opens. */
  trapFocus: _propTypes2.default.bool,
  /** Whether or not the trigger responds to clicks. **Warning**: You probably don't want to use `respondsToClick` and `receivesFocus` *and* `respondsToFocus` all together, because they can have clashing interactions. e.g. When the popover that trapped focus closes, it returns focus to the trigger, which then causes the popover to open again. */
  respondsToClick: _propTypes2.default.bool,
  /** Whether or not the trigger responds to `mouseenter` and `mouseleave` events. */
  respondsToHover: _propTypes2.default.bool,
  /** Whether or not the trigger responds to `focus` and `blur` events. */
  respondsToFocus: _propTypes2.default.bool,
  /** If `true`, the trigger will not work. */
  disabled: _propTypes2.default.bool,
  /** Extra props to pass to the Popover component. */
  popoverProps: _propTypes2.default.object,
  /** Extra props to pass the `<div>` around your trigger content. */
  triggerProps: _propTypes2.default.object,
  /** Callback that is invoked when the popover opens. */
  onPopoverOpen: _propTypes2.default.func,
  /** Callback that is invoked when the popover closes. */
  onPopoverClose: _propTypes2.default.func
};
PopoverTrigger.defaultProps = {
  display: 'inline-block',
  disabled: false,
  renderHiddenContent: false,
  receiveFocus: true,
  trapFocus: false,
  respondsToClick: true,
  respondsToHover: false,
  respondsToFocus: false,
  popoverProps: {},
  triggerProps: {}
};
exports.default = PopoverTrigger;